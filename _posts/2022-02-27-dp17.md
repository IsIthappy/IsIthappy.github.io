---
title: "행렬 곱셈 순서"
excerpt: "DP지만 O(N^3) 시간 복잡도를 자랑하는 문제"

categories:
    - DP
tags:
    - [PS, DP]
last_modified_at: 2022-02-27
---
# 행렬 곱셈 순서 문제 풀이
1. **문제의 이해**
2. 소스코드

백준 문제 링크 [https://www.acmicpc.net/problem/11049](https://www.acmicpc.net/problem/11049)


---


# 1. 행렬 곱셈 순서 문제의 이해

문제를 처음 봤을 때 일단 분석한 key point가 될 만한 조건들은 

1. 입력으로 주어진 행렬의 순서를 바꾸면 안 된다.
2. 항상 순서대로 곱셈을 할 수 있는 크기만 입력으로 주어진다.

이 두가지가 일단 힌트가 될 수도 있겠구나 판단했다. 

행렬의 순서를 바꿀 수도 있다고 하면, 이걸 정렬해서 greedy하게 풀 수 있는지.... 완전탐색으로 풀어야만 하는지 막막했는데, 그냥 주어진 입력 그대로 곱하면 되지만 특정 부분에 괄호를 씌워서 먼저 계산할 수 있다는 소리니까 말이다.

>즉, 현재 문제 상황들을 정리해보면

1. 앞에서부터 순서대로 곱하지만 괄호를 씌워서 인접행렬을 합치는 것은 가능함
2. 앞에서부터 곱한거랑 뒤에서부터 곱한거랑 값이 다름. (양 끝 값은 그대로인데, 중간 지점을 뭐부터 곱하느냐에 따라 결과가 달라진다.)
3. 하나가 추가됨에 따라서 갱신되는 값들이 N개임. -> 앞에서부터는 어떻게 해서든 최소값이 갱신되어 있겠지만 새로 추가된 행렬을 껴서 먼저 곱할 수도 있기 때문이다.
4. 입력에 따라 완전 달라질 것이기 때문에 규칙을 찾는 문제는 아닌 것 같음.

>이때, 이 3번째 문제점때문에 for문을 돌리는 완전탐색 기반, 재귀함수 기반 무엇으로 풀게 되던 중복되어 계산되는 작은 문제들이 존재한다. 

예를 들어서 1 ~ 8번까지 행렬이 있다고 할 때, 9번 행렬이 추가되면?

1 ~ 8까지의 최소값은 구해져있고, 그 중간에 최소값을 구하기 위해 2부터 5까지라던지 이런 경우들을 다 구한적이 있는데 이 값들을 9번 행렬이 추가되면 다시 다 구해야하기 때문이다.

중복되어 작은 문제들이 존재한다는 것은 DP를 활용해볼까?라는 생각을 떠올릴 수 있고 일단 이런 완전탐색으로 풀면 괄호를 쳐서 중간 부분 행렬을 합치는 것에 대해서는 어떻게 관리를 해야할지 막막해서 완전탐색은 일단 풀이 선택지에서 없애고 가야한다.

>중복되어 계산되는 것을 dp state로 정의하여 i번째부터 j번째까지 행렬 곱의 최소값을 저장해보자.

state를 정의했으니 이제 이 최소값을 어떤 방식으로 구할 것인지를 생각해야 한다.

처음 들었던 생각으로는 (1 ~ i)까지의 최소값이 구해져 있다고 할 때, i+1 번째 행렬을 추가해서 최소값을 아래칸, 왼쪽칸 둘 중에 하나에서 현재 행렬을 곱하며 최소값을 갱신하게 구현했더니

```c
dp[j][i] = min(dp[j][i - 1] + mat[j].s * mat[i].s * mat[i].e, dp[j + 1][i] + mat[j].s * mat[j].e * mat[i].e); // 처음 생각했던 점화식
```
1 100
100 1
1 100
100 1

이라는 직관적으로 아주 쉽게 생각할 수 있는 반례에서 틀렸다.
(1 -2) * (3- 4) 행렬곱은 하지 않기 때문.

즉, 내 점화식은 중간 부분 건너뛰고 극단적으로

1 (234)
(123) 4

이 둘중에 최솟값만 갱신하고 있었음

(12)(34)(56) 이런건 못보는 점화식이었지

그래서 아래에 구상한 3중 for문이 진짜 이 문제의 풀이였다.


---

# 2. 소스코드

```c
#include <stdio.h>

typedef struct {
	int s;
	int e;
}node;

node mat[501]; // 각 행렬의 N*M 정보가 저장될 구조체 배열
int n;
void init();

int dp[501][501];  // i 부터 j까지 행렬곱의 최소값이 갱신될 dp 배열
void do_dp();
int min(int, int);

int main()
{
	init();
	do_dp();
	printf("%d", dp[1][n]);
	return 0;
}

void do_dp()
{
	for (int i = 2; i <= n; i++) // 2~부터 n까지 진행해야지
	{
		dp[i - 1][i] = mat[i - 1].s * mat[i - 1].e * mat[i].e; // 한칸 간격은 비교할 것도 없이 그냥 채우면 되고
		for (int j = i - 2; j > 0; j--)
		{
			for (int k = 0; k < i-j; k++)
				dp[j][i] = min(dp[j][i], dp[j][j + k] + dp[j+k+1][i] + mat[j].s * mat[j+k+1].s * mat[i].e);
			// 이 마지막 k를 이용한 for문이 핵심이었다. 이건 손으로 써서 한번 생각해보면 어떤 생각으로 이렇게 풀었었는지 생각날꺼다. 손으로 써
		}
	}
	return;
}

int min(int a, int b)
{
	if (a==0 || a > b)
		return b;
	return a;
}

void init()
{
	scanf("%d", &n);
	int a, b;
	for (int i = 1; i <= n; i++)
	{
		scanf("%d %d", &a, &b);
		mat[i].s = a;
		mat[i].e = b;
	}
	return;
}
```
