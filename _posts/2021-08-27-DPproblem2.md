---
title: "발전소 문제"
excerpt: "외판원 순회와 유사한 문제"

categories:
    - DP
tags:
    - [PS, DP, Bit Masking]
last_modified_at: 2021-08-27 
---
# 발전소 문제 풀이
1. **발전소 문제의 이해**
2. **Top - down DP로 풀 생각을 한 이유**
3. 소스코드
4. **후기**

백준 문제 링크
[https://www.acmicpc.net/problem/1102](https://www.acmicpc.net/problem/1102)


---


## 1. 발전소 문제의 이해

문제에서 주어지는 발전소들의 상태와 정상 작동을 해야하는 발전소의 최소 개수가 주어진다.

이때 발전소의 상태, 최소 개수, 발전소의 개수 <=16

이 모든 것을 고려할 때 단순하게 완전 탐색으로 모든 경우를 다 본다면 O(N!)에 근사한 시간복잡도가 나오게 될 것이다. 즉, 다항시간안에 문제를 해결할 수 있는 방법을 생각해야 한다.


---

## 2. Top - Down DP로 풀 생각을 한 이유

풀이를 크게 세가지 방법으로 생각해봤다.
완전 탐색을 할때 탐색되는 경로들을 보면 부분적으로 겹치는 state들이 분명히 존재한다. 따라서 이걸 한번만 계산해주기 위해 DP를 사용해볼까? 라는 생각을 할 수 있다.

---

- **bottom - up DP 로 풀기(hard?)**

bottom - up 방식으로 풀기에는 for문으로 state들을 빠짐없이 체크하기에 무리가 있어보인다. 어떻게 state 상태들을 관리할 것인가?

DP 배열 state 정의하기가 쉽지 않다.

발전소들의 상태를 bitmasking 하면 for문으로 차례차례 비트를 켜주면서 진행하는데 몇개의 발전소가 켜졌는지 카운트하기가 조금 난감해진다.

그렇다고 비용을 state로 잡고 풀면 같은 비용을 가지는 여러개의 state들이 발생할 경우 처리가 곤란해진다.

고로 바텀업 방식으로 푸는건 포기했다.

---

- **우선순위큐 bfs +  DP 로 풀기**

직관적으로 이해가 제일 빠른 풀이라고 생각한다.

우선순위 큐를 활용해서 bfs를 돌리면 켜져있는 발전소의 카운트, 최소값 보장 둘다 가능하기 때문이다.

>단, 발전소를 켜가는 순서가 정답에 영향을 주기 때문에 다른 state에서 발전소를 켰다고 현재 내 state에서 방문을 못하는건 아니다. 방문 체크는 현재 state에서만 이루어져야 한다.

따라서 이때 `DP state를 현재 발전소들의 상태`로 잡고 최소비용을 저장해둔다.

중복 state가 발생할때마다 최소가 아니면 큐에서 빼버리면서 경우를 줄여가면 충분히 컨트롤이 가능할 것이다.

큐에 값을 넣을 때, 뺄 때 모두 현재 이 값이 최소값인지 확인하는 과정이 필요할 것이라고 생각한다.

---

- **top - down DP 로 풀기**

제일 단순하게 풀 수 있는 방법이라고 생각한다.

외판원 순회 문제랑 거의 똑같으므로 state를 잡고 재귀를 돌릴려고 했는데 문제가 생긴다.

내가 외판원 순회 문제를 풀었던 방식인 내가 원하는 상황을 최종 state로 잡고 거슬러 내려가며 풀려고 한다면

1. 처음에 고장나지 않은 발전소 bit는 끌 수 없음. --> 즉, 비트를 끌 때마다 처음 상태와 계속 비교해야함.
2. 최종 상태 state를 조합으로 구해내서 모든 경우에 대해 구해봐야함.
(최종 상태가 모든 bit가 켜진 상황이 아닐 수도 있기 때문)


물론 풀 수는 있겠지만 상당히 복잡해진다. 그래서 외판원 순회 [000001] state -> [111111] state 풀이를 이해하고 돌아왔다.


---

## 3. 소스 코드

```c
#include <stdio.h>
#define MAX 10000000
#define MIN(a,b) (((a) < (b)) ? (a) : (b))
int dp[1<<16];
int arr[16][16];
int n,p,sn;

int dfs(int,int);

int main()
{
    for(int i=0;i<1<<16;i++) // 비용 중에 0이 있기 때문에 -1로 초기화해서 구분해줘야함.
        dp[i] = -1;
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
            scanf("%d",&arr[i][j]);
    }
    sn = 0;
    int sp = 0;
    getchar();
    for(int i=0;i<n;i++)
    {
        char buf;
        scanf("%c",&buf);
        if(buf == 'Y')
        {
            sp++;
            sn += 1<<i;
        }
    }
    scanf("%d",&p);
    int val = dfs(sp,sn);
    if(val == MAX) // 불가능한 상황인지 체크 해야함
        printf("-1");
    else
        printf("%d",val);
    return 0;
}

int dfs(int count, int cur)
{
    if(count>=p) // 켜진 발전소의 개수가 조건을 충족한 경우
        return 0;
    if(dp[cur] >-1) // 이미 계산한 state의 경우 값을 return
        return dp[cur];
    dp[cur] = MAX;
    for(int i=0;i<n;i++)
    {
        if((1<<i & cur) != 0)
            continue;
        int val = MAX;
        for(int j=0;j<n;j++)// 현재 켜져있는 발전소 중에서 최소의 비용으로 킬 수 있는 발전소 찾기
        {
            if((1<<j & cur) == 0)
                continue;
            val = MIN(val, arr[j][i]);
        }
        dp[cur] = MIN(dp[cur], dfs(count+1,cur|1<<i) + val);
        // dp 배열에 저장되는 값을 보면 내가 방문하지 않은 지점들을 최소비용으로 키는 값들이 들어온다. 
        //뭘 킨건지는 알 필요가 없으니 신경쓰지 않는다.
    }
    return dp[cur];
}

```

탑다운 DP가 최종 state에서 작은 state로 거슬러 내려가는거 아닌가요?! 

표현하기 나름이지 중복호출만 막아주면 되는 것 아닌가 싶다. 이것도 나중에 또 공부하다보면 매끄러운 표현을 찾을 수 있지 않을까


---

## 4. 후기

외판원 순회, 발전소 문제를 top - down DP로 풀고 나니까 약간 dfs에 DP를 섞은 느낌이라는 것이 강하게 느껴진다.

처음에는 어떻게 중복호출을 막는건지 도저히 이해가 안갔는데 어떤 값이 저장되는지를 이해하니까 dfs에 DP를 활용해서 탐색할 수도 있다는걸 알게되었다.

자주 써먹지 않을까 싶다.