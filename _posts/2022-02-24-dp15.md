---
title: "팰린드롬?"
excerpt: "점점... 전형적인 틀에서 벗어나기 시작하는 DP 문제들"

categories:
    - DP
tags:
    - [PS, DP]
last_modified_at: 2022-02-24
---
# 팰린드롬? 문제 풀이
1. **문제의 이해**
2. 소스코드

백준 문제 링크 [https://www.acmicpc.net/problem/10942](https://www.acmicpc.net/problem/10942)


---


# 1. 팰린드롬? 문제의 이해

문제를 처음 딱 봤을 때 파악한 문제점은 크게 두가지였다.

1. 팰린드롬 판단 부분의 시작 부분과 끝점이 고정되어있지 않다.
2. 그렇다고 매번 팰린드롬을 판단하면, (수열의 길이 * 질문의 개수) 시간초과가 나온다.

저 팰린드롬 판단 부분의 시작 부분이나 끝점이 고정되어있지 않다는게 이번 문제의 핵심이었던 것 같다.

그래서 수열을 입력받으면서 추가된 수에 의해 형성되는 팰린드롬을 2차원 배열에 시작점, 끝점으로 다 갱신을 해두면 될 줄 알았다. O(N^2) 이니까, 수열의 길이는 2000 * 2000 시간안에 충분히 될 줄 알았으나.....

이게 완전 탐색이랑 다를게 뭐야? 라는 생각이 들었고 시간복잡도를 다시 생각해보니.....

(입력받는 수열의 길이 * 시작점부터 현재 입력받은 숫자의 위치까지 * 그때마다 팰린드롬 판단)

O(N^3) 이었다... 시간초과 ㅎㅎ

그래서 들은 생각이 이건 무조건 DP라는 생각이었다. 한번 판단한 팰린드롬 부분에 대해서는 다시 확인하면 안된다. 라는 생각이 들었고... 곰곰히 생각해본 결과

2차원 배열을 이용해서 check[시작점][끝점] 으로 팰린드롬 여부를 저장해둬서 이용해야 하는 것 까진 맞고 숫자 하나를 추가할 때마다 어떻게 갱신이 추가적으로 이루어지느냐가 핵심이었다.

>현재 숫자가 추가될 때, 팰린드롬 여부를 어떻게 효율적으로 판단할 것인가.

DP 관점에서 봤을 때, 힌트는 이미 앞부분은 팰린드롬 판단이 끝나있다는 것을 이용해야 한다.

1. 수열의 길이가 1이라면, 무조건 팰린드롬
2. 수열의 길이가 2라면, 시작과 끝이 같아야함
3. 수열의 길이가 2보다 크면, 시작과 끝이 같아야하고, 앞뒤를 댕강 자른 부분이 팰린드롬이어야함.

>이때 앞뒤를 댕강 자른 부분은 이미 판단 여부가 끝나있는 부분이라는 것이 이 문제를 DP로 푸는 것의 핵심이었다...

---

# 2. 소스코드

```c
#include <stdio.h>
#include <stdbool.h>

bool check[2001][2001];
int arr[2001];
int n;
void init();

void do_dp();
void print_ans();

int main()
{
	init();
	do_dp();
	print_ans();
	return 0;
}

void print_ans()
{
	int m,a,b;
	scanf("%d", &m);
	for (int i = 0; i < m; i++)
	{
		scanf("%d %d", &a, &b);
		printf("%d\n", check[a][b]);
	}
	return;
}

void do_dp()
{
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= i; j++)
		{
			if (i - j == 0) // 자기 자신은 무조건 팰린드롬
				check[j][j] = true;
			else if (i - j == 1 && arr[i] == arr[j]) // 현재 보고자 하는 범위가 2칸일때
				check[j][i] = true;
			else if (arr[i] == arr[j] && check[j + 1][i - 1]) // 범위가 3칸 이상이고, 시작과 끝이 같다면? 중간 지점이 팰린인지 확인
				check[j][i] = true;
		}
	}
	return;
}

void init()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%d", &arr[i]);
	return;
}
```
