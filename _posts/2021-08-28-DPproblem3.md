---
title: "계단 수"
excerpt: "비트마스킹을 통한 DP"

categories:
    - DP
tags:
    - [PS, DP, Bit Masking]
last_modified_at: 2021-08-28 
---
# 계단 수 문제 풀이
1. **계단 수 문제의 이해**
2. **Bottom up DP로 풀 생각을 한 이유**
3. 소스코드
4. **후기**

백준 문제 링크
[https://www.acmicpc.net/problem/1562](https://www.acmicpc.net/problem/1562)


---

# 1. 계단 수 문제의 이해

100자리까지의 수 중에서 0~9 숫자가 다 사용되고 454565 같이 자리마다의 차이가 1씩만 나는 수를 다 카운트 해줘야하는 문제다. 

일단 입력 사이즈만 봐도 100자리이고 0~9 숫자가 다 사용되었는지도 확인을 해야하기 string을 통한 완전 탐색은 절대 불가능할 것이란 생각이 든다.


---

# 2. Bottom -up DP로 풀 생각을 한 이유

완전 탐색이 안되면 작은 문제를 활용해서 큰 문제로 쌓아올려가야지 뭐 어쩌겠나...

자릿수를 늘려가며 일어나는 상황을 점화식으로 표현하면 되겠다 싶었다. 이러면 뭐 bottom-up 방식으로 구현해야지.

DP 배열에 필요한 state는 크게 3가지이다.

- **1. 맨 뒷자리 수**

계단 수를 만들어야하기 때문에 추가된 자릿수에 사용된 숫자가 무엇인지를 알아야 다음에 숫자를 추가할 때 계속해서 계단 수를 만들어줄 수 있다.

- **2. 현재 숫자의 자릿수의 크기**

몇번째 자릿수인지 알아야하는건 뭐 당연한 부분이다.

- **3. 0~9까지 사용된 숫자 표현**

제일 중요한 state다. 계단 수 중에서 0~9의 숫자가 모두 사용된 것들만 카운트 해줘야하기 때문에 0~9까지 어떤 숫자가 사용되었는지 상태표시를 해줘야한다. 비트마스킹이 딱 떠오르는 state다.

현재 자릿수의 크기를 굳이 state로 잡아서 DP 배열에 저장해야 할까 싶었다. for문을 돌리면 알아서 몇번째 자릿수인지 카운트가 될꺼라고 생각했는데 그렇게 되면 DP에서 이전 실행에 대한 값을 읽어와야하는데 수정된 DP값을 읽어오게 되는 상황이 벌어진다. 한 라인을 읽음과 동시에 덮어써버리기 때문이다.

그래서 이 세가지 state가 다 필요한 것 같다. 내 생각에는?....


---

# 소스 코드

```c
#include <stdio.h>
#define DIV 1000000000

int dp[101][10][1<<10];
int n;

void fill_dp();

int main()
{
    scanf("%d",&n);
    for(int i=1;i<10;i++)
        dp[1][i][1<<i] = 1;
    fill_dp();
    int sum = 0;
    for(int i=0;i<10;i++)
        sum = (sum+dp[n][i][(1<<10)-1])%DIV;
    printf("%d",sum);
    return 0;
}

void fill_dp()
{
    for(int i=2; i<=n; i++)
    {
        for(int j=0;j<10;j++)
        {
            for(int k=0;k<1<<10;k++)
            {
                if(dp[i-1][j][k] == 0)
                    continue;
                if(j == 0) // 0이면 다음 자리 숫자는 무조건 1이다.
                {
                    dp[i][j+1][k|1<<1] += dp[i-1][j][k];
                    dp[i][j+1][k|1<<1]%= DIV;
                }
                else if(j == 9) // 9면 다음 자리의 숫자는 무조건 8이다.
                {
                    dp[i][j-1][k| 1<<8] += dp[i-1][j][k];
                    dp[i][j-1][k | 1<<8] %= DIV;
                }
                else
                {
                    dp[i][j+1][k | 1<<(j+1)] += dp[i-1][j][k];
                    dp[i][j+1][k | 1<<(j+1)] %= DIV;
                    dp[i][j-1][k | 1<<(j-1)] += dp[i-1][j][k];
                    dp[i][j-1][k | 1<<(j-1)] %= DIV;
                }
            }
        }
    }
    return;
}
```

크게 뭐... 설명할 부분이랄게 없는 것 같다. state정의가 어려웠지 정의만 제대로 한다면 쉬운 문제에 속하는 것 같다.

`O(N*(1<<10)*10)` ---> `O(N)` 의 시간복잡도가 나온다.

---

# 후기

일단 이 문제 풀면서 당황한 부분이 세가지이다.

- **1. 세가지 state가 필요해서 3차원 DP 배열을 만든 것**

DP 배열을 3차원으로 만들어본적이 한번도 없어서 그랬는지 잘 모르겠는데 이상하게 필요한 state의 수는 세개라는걸 알면서

현재 자리 숫자를 어떻게 다음 state에 넘겨주지?

현재 몇자리인지 어떻게 표시하지?

어떻게해서든 state를 한개 줄이려고 했다... 그냥 3개다 가져다 쓰면 되는건데...

- **2. DP 배열 사이즈를 dp[][][(1<<10)-1] 로 잡아서 런타임 에러가 났던 것.**

이게 제일 멍청했다. 필요한 bit의 수가 10개니까 (1<<10) -1 이게 맞긴 하지 1111111111 이므로.

근데 배열의 index는 0부터 시작하니까... 저렇게 잡아주면 1111111110 여기까지밖에 표현이 안되는건데.... 무슨 생각으로 저렇게 잡아두고 어디서 index 참조를 잘못하고 있는거지?! 했는지 모르겠다.

- **3. 1<<10 하니까 우와 11자리수?**

미친거다... 10000000000 이게 10진수가 아니라... 2진수니까... 1024다... 이것도 뭐 아직 bit연산자가 익숙하지 않아서 2진수라는 생각을 못한 것 같다.