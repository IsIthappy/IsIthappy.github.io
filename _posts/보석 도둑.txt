보석 도둑 1202

The difficult economic situation in the country and reductions in government agricultural subsidy funding have caused Mirko to change his career again, this time to a thief.

-> in government agricultural subsidy funding 이게 무슨 소린지 모르겠다.

His first professional endeavour is a jewellery store heist.

-> endeavour 은 노력 아닌가?, heist는 뭐더라

He plans to store all his loot in these bags

-> loot는 뭐야?


원래 보석 도둑 문제에서 가방 하나에다가 여러 보석을 넣었다 뺐다, 해야하니까 2차원 DP에다가 뺐다, 넣었다 해서 
답을 구해내면 됐었는데

이번에는 가방이 여러개다...., 심지어 가방 하나에 보석이 하나!

DP로는 일단 생각이 절대 안나긴 함.,  가방 여러개를 어떻게 처리할건데?

알고리즘 커닝해보니까 그리디네?

-> 일단 제일 무겁고, 가치 높은애로 박아버리면 그 가방은 더 이상 볼 것도 없다.
핵심은 가방 무게와 제일 근접하면서도 가치가 제일 높은애를 찾는 것인데...

(도저히 모르겠네)


1. 보석은 일단 가치 순으로 뽑아내야 하고,
2. 해당 무게보다 크거나 같은 가방을 찾아서 보석을 담아주고 그 가방은 list 목록에서 제거하면 된다.

(즉, 이분 탐색을 하고, 해당 node를 제거해야 한다는 의미인데 이진 트리에서 삭제가 가능한가? 이게 핵심)

key값의 중복을 허용하는 multiset STL을 이용해서 풀어야 할 듯?


내 알고리즘은
1. 보석 가치 내림차순으로 정렬
2. 가방 multiset을 통해 정리

보석을 꺼내서 해당 보석을 넣을 수 있는 lower bound 가방을 찾아서 multiset에서 그 가방 erase

보석을 다 넣거나, 가방이 모자르거나 할때까지 이 과정을 반복.

보석 sort과정 O(NlogN) -> sort 함수의 경우 pivot을 최악으로 선택해 O(N^2) 되는 과정까지 방지가 되어있다.
multiset에 가방 삽입 과정, O(logN)
보석 꺼내서 (N) * lower_bound 탐색 * (logn) * 해당 가방 제거(log n)

가방을 탐색해서 찾고 지우면서 재배치 과정이 들어가기 때문에 오래걸릴 수 밖에 없다.


하지만 우선순위 큐를 활용한다면?
1. 가방을 무게 오름차순으로 정렬
2. 보석을 무게 오름차순으로 정렬

1. 가방을 순서대로 for문을 돌린다.
2. 가방의 무게보다 작거나 같은 보석들을 싹 다 우선순위 큐에다가 넣는다.
(우선순위는 보석의 가치이다.)
-> !q.empty() 라면 하나 빼서, 넣는다.

이 과정을 가방을 다 볼때까지 반복한다.
가방, 보석 정렬 NlogN
N개의 가방 탐색 * (logn 경우마다 보석 빼기) + Nlogn

우선순위 큐를 이용하면 매번 탐색해서 제거하지 않기 때문에 더 효율적이라고 할 수 있다.





1. set STL 정리하고, ---> STL 정리 노트
2. 우선순위 큐 STL 정리하기
3. class와 구조체 정리하고, ---> C++ 정리 노트
4. 반복자란 무엇인지 정리하고 ----> C++ 정리노트







class 와 구조체의 차이

(일단 기본적으로 C의 구조체와 C++의 구조체는 조금 다르다.)

C에서의 struct는 연관있는 데이터를 묶는 기능만 가지고 있지만, C++에서는 class의 동작방식과 일치하기 때문에
함수 선언 및 정의, 생성자 및 소멸마 선언 및 정의, 상속 구조 등등을 사용할 수 있다.


```c++
struct node{
    int x;
    int y;
};
```

이게 지금껏 사용해온 구조체이다.

여기서 C++의 class를 사용하고 싶다면?

```c++
class node{
    int x;
    int y;
}
```

그냥 struct에서 class로 바꿔써주기만 하면 된다. C++에서는 struct(구조체)가 class의 일종이기 때문이다.


>c++에서의 class와 구조체의 차이는 멤버의 접근 지시자의 차이가 있다.

>또한 class 사용시 typedef 없이 그냥 바로 class의 이름으로 선언이 가능하다.
(struct node 변수이름 이렇게 안쓰고 node 변수이름이 가능하다는 소리)

struct(구조체)는 모든 멤버의 접근 지시자가 항상 public이고

class는 멤버별로 각각 다른 접근 지시자를 정해줄 수 있다.
(default 값으로는 private 설정이 된다.)

1. public : 어디에서나 접근 가능
2. protected : 상속관계에 있을 때, 유도 class에서의 접근 허용
3. private : class 내에 정의된 함수에서만 접근 허용


```c++
class point
{
private:
    int x;
    int y;
public:
    void init()
    {
        x = 0;
        y = 0;
    }      
}
```

이런식으로 사용할 수 있다.

그니까 요약하자면, c++에서 구조체와 class 역할의 차이는 없다.
둘 다 data들을 묶는 역할을 하니까, 하지만 구조체는 접근제어 지시자가 public이고,
c++은 사용자가 지정해 줄 수 있으며, default값은 private이라는 것이다.


https://inpages.tistory.com/135#:~:text=%EB%B0%98%EB%B3%B5%EC%9E%90%EB%8A%94%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%97%90%20%EC%A0%80%EC%9E%A5%EB%90%9C,%EC%97%90%EB%8F%84%20%EC%97%AC%EB%9F%AC%20%EC%A2%85%EB%A5%98%EA%B0%80%20%EC%9E%88%EB%8B%A4.
-> 반복자 설명

https://hoondev.tistory.com/53
-> lower bound 설명 되게 잘 나와있음.

https://blockdmask.tistory.com/80
-> multiset 사용법


* end() 함수는 끝이 아니다
컨테이너를 다룰 때 자주 쓰이는 end()라는 멤버함수는 컨테이너의 맨 마지막 원소를 가리키는게 아니다. end()가 가리키고 있는 것은 맨 마지막 원소의 바로 다음번 원소이다. 
따라서 이러한 반복자를 past-the-end 반복자라고 부른다. (종점을 지나쳐버린 곳을 가리키는 반복자) 
 
end() 멤버 함수를 통해 얻어지는 반복자는 결과적으로 아무 의미가 없는 것을 가리키고 있는 것이며, 이 반복자가 가리키는 것을 참조하면 예상치 못한 오류가 발생하게 된다. 
 
또한 아무 원소도 없는 컨테이너의 begin()과 end()는 같다. 