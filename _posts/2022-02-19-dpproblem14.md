---
title: "동전 1"
excerpt: "tc의 크기가 작아서 완전 탐색으로 가지치기 잘하면 될 줄 알았던 문제"

categories:
    - DP
tags:
    - [PS, DP]
last_modified_at: 2022-02-19
---
# 동전 1 문제 풀이
1. **문제의 이해**
2. 소스코드

백준 문제 링크 [https://www.acmicpc.net/problem/2293](https://www.acmicpc.net/problem/2293)


---


# 1. 동전 1 문제의 이해

문제를 처음 보고 든 생각은 TC의 크기가 좀 작네? 였다. 뒤에 덧붙여서 경우의 수 크기는 2^31보다 작다고 나와있긴 했지만 일단 설마 경우의 수가 그만큼 나오겠어? 라는 생각만 들었다.

보통 dfs가 아니라 DP로 해당 값을 만들 수 있는 값을 찾는다고 하면 DP[cur] += DP[cur-coin[i]]; 이런식으로 계속 쌓아간다. ``4를 만드는 경우의 수 = 3을 만드는 경우의 수 + 1을 만드는 경우의 수`` 이런식으로 말이다.

>사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.

하지만 위 조건 때문에 (4) = (1, 2 , 1) VS (1, 1, 2) 둘이 같은 경우라 (3+1)에서 넘어오는 경우 (2+2)에서 넘어오는 경우가 중복 카운트가 되어 버린다...

그렇게 경우의 수가 겹치기 때문에 DP로 푸는 것은 어렵다고 판단했고, 가지를 잘 쳐내서 dfs를 돌리기로 했다.

1. 동전을 크기 순으로 정렬
2. 1번 동전 넣을 수 있는 한 최대로 넣고, 줄여가면서 재귀 호출
3. 다음 동전 최대로 넣고, 줄여가며 재귀 호출

이러면 각 동전의 개수를 이용해 가치를 구해나가기 때문에 중복 카운트를 막을 수 있고, 동전을 크기 순으로 정렬했기 때문에 도중에 목표 가치를 만들 수 없다면 가지를 쳐낼 수 있게 된다. 그래서! 이렇게 풀어봤다! 아니 동전 100개, 만들어야하는 최대 가치 10,000 충분할 것 같았다.

하지만 역시나 시간초과에 걸렸고... 조금 더 효율적으로 dfs를 구성할 수는 없나 보다가

10,000의 가치를 만들기 위해서 5,000을 거쳐오는 경우가 수없이 많을텐데 이걸 재귀 호출로 일일이 처음부터 5,000까지 쌓아올리고 그 뒤에 10,000까지 만드는 과정이 들어가므로 이렇게 풀면 시간초과에 걸릴만도 하네... 라는 생각이 들었다.

다시 고민해본 결과.. 이 dfs 알고리즘을 dp로 옮기면 되지 않을까? 라는 생각을 했다.

>각 동전을 이용해서 만들 수 있는 가치들에 미리 뿌려놓는다? 라고 생각하면 될 것 같다.

1. 첫번째 동전을 이용해서 만들 수 있는 가치들에 전부 dp++
2. 두번째 동전을 이용해서 만들 수 있는 가치들에 전부 dp++

이러면 저 dfs 사고 방식 그대로 따라가지만, 가능한 경우들만 쌓아가기 때문에 불가능할 때까지 재귀를 쌓아올리는 불필요한 호출이 없어지기 때문에 시간적으로 훨씬 이득을 볼 수 있게 된다.

>사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.

이 조건때문에 조금 빙빙 돌아서 풀게 되긴 했지만... 좋은 문제였던 것 같다.

---

# 2. 소스코드

```c
#include <stdio.h>
#include <stdlib.h>

int arr[100];
int n,k;

int dp[10001];

void init();
int cmp(const void*, const void*);
void do_dp();

int main()
{
	init();
	do_dp();
	printf("%d", dp[k]);
	return 0;
}

void do_dp()
{
	dp[0] = 1;
	for (int i = 0; i < n; i++)
	{
		for (int j = arr[i]; j <= k; j++)
			dp[j] += dp[j - arr[i]];
	}
	return;
}

void init()
{
	int buf,t;
	scanf("%d %d", &t, &k);
	for (int i = 0; i < t; i++)
	{
		scanf("%d", &buf);
		if (buf > k) // 동전 하나의 가치 자체가 K보다 크면 걘 필요없는 정보임.
			continue;
		arr[n++] = buf;
	}
	qsort(arr, n, sizeof(int),cmp); // 동전이 크기 순으로 주어진다는 말이 없으므로 일단 정렬하는게 좋음. (굳이 하지 않아도 되긴 함.)
	return;
}

int cmp(const void* a, const void* b)
{
	int num1 = *(int*)a;
	int num2 = *(int*)b;
	if (num1 < num2)
		return -1;
	else if (num1 > num2)
		return 1;
	return 0;
}
```
