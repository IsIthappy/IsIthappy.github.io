---
title: "피보나치 3"
excerpt: "피보나치 수열은 피사노 주기를 가진다."

categories:
    - Math
tags:
    - [PS, Math]
last_modified_at: 2022-01-29
---
# 피보나치 3
1. **피보나치 3 문제의 이해**
2. 소스코드
3. **후기**

백준 문제 링크 [https://www.acmicpc.net/problem/2749](https://www.acmicpc.net/problem/2749)


---

# 피보나치 3 문제의 이해

이 문제의 경우 1,000,000,000,000,000,000 번째 까지의 피보나치 수를 1,000,000 으로 나눠서 출력하는 문제이다... 하지만 피보나치 수열의 경우 n = 48 만 되어도 int 자료형의 표현 범위를 뛰어넘어버리는 가파른 기울기를 보유하는 수열이다.

일반적으로 피보나치를 단순하게 푸는 방법은

1. 재귀함수 O(N^2)
2. 반복문 O(N)
3. Memoization을 통한 재귀함수 O(N~) -- 호출이 되긴 하지만 중복 연산을 하지는 않음

어찌 어찌 자료형을 새로 만들어서 푼다고 하더라도 재귀 함수를 통한 DP 로는 Memory 용량이 부족해서 풀지 못하고 반복문을 통해 구현한다고 하더라도 연산 횟수가 너무 많기 때문에 시간초과에 걸려버린다.

>일반적인 점화식으로는 풀 수 없다는 것을 알 수 있다.

이렇게 modular 연산까지 시키는 것을 보니 fibonach 수열도 뭔가 주기를 가지나? 라는 생각이 들긴 했었는데 그걸 직접 구해보기엔 너무 막막하기 때문에 구글링을 해봤다.

아니나 다를까... 피사노라는 주기를 가진다.

MOD가 10^k (k>2) 의 값을 가질때, 피보나치 수열에 Modular 연산을 할 시, 15*10^(k-1) 의 주기를 가진다고 한다.

>즉, n번째 값을 구하기 위해 n % 15*10^(k-1) 번째의 값을 구해주면 되는 것이다.

MOD가 10^k 꼴이 아니라면? 흠.... 반복문으로는 풀지 못하겠지. 그런 문제가 피보나치 6의 경우이다.


---


# 소스코드

```c
#include <stdio.h>

#define MOD 1000000

int fibo[3];

void do_fibo(int);

int main()
{
	long long n;
	scanf("%lld", &n);
	if (n == 0)
		printf("0");
	else if (n == 1)
		printf("1");
	else
	{
		n %= 15 * MOD / 10; // 15*10^(k-1) 을 통해 주기 구하기
		do_fibo(n);
		printf("%d", fibo[2]);
	}
	return 0;
}

void do_fibo(int n)
{
	fibo[1] = 0;
	fibo[2] = 1;
	for (int i = 2; i <= n; i++)
	{
		fibo[0] = fibo[1];
		fibo[1] = fibo[2];
		fibo[2] = (fibo[0] + fibo[1]) % MOD;
	}
	return;
}

```

---


# 후기

솔직히 이것도 처음에는 DP 배열을 만들어서 차곡차곡 쌓아올렸는데 바보같은 짓이었다.

피보나치 수열은 현재값을 결정 짓기 위해서 이전 값 두개만 있으면 되기 때문에 굳이 저어어어어어 멀리 계산했던 값까지 가지고 있을 필요가 없다.

>물론 재귀로 구현하면 기억해야한다. 이 때문에 재귀는 비효율적!