---
title: "iterator(반복자)란?"
excerpt: "그냥 pointer와 같은 존재라고 생각하자."

categories:
    - Cpp
tags:
    - [Note, Cpp]
last_modified_at: 2022-02-13
---



# iterator란 무엇인가?


구글에 여러 블로그, 뇌를 자극하는 C++ STL을 읽어보고 간단하게 정리하는 글.

일단 iterator를 종종 봐왔긴 했으므로 이게 어떻게 구현되어있고 어떻게 동작하는 것인지 궁금해서 찾아봤지만 아쉽게도 그렇게 자세하게는 찾지 못했다.

>내부구현 같은 것이 궁금하다면 어디서 정보를 찾아볼 수 있는지 잘 모르겠다. 이런게 오픈소스로 볼 수 있으면 안되는건가??? 사실 내가 scanf 동작이 궁금하긴 하지만 내부 구현이 어떻게 되어있는지는 모르고 사용하는 것처럼... STL도 어느정도는 그냥 받아들이고 공부해야겠다.


우선 iterator는 포인터의 개념과 상당히 비슷하다.

1. iterator는 컨테이너 내부의 원소를 가리키고 접근할 수 있어야 한다.(*)
2. 반복자는 다음 원소로 이동하고 컨테이너의 모든 원소를 순회할 수 있어야 한다.(++,!=,==)


---

## begin(), end() 란 무엇인가?

>STL의 모든 컨테이너는 자신만의 반복자를 제공한다.

컨테이너의 멤버 함수 begin(), end()가 [begin, end) 를 가리키는 iterator를 반환한다.

여기서 주의해야 할 것은 end()는 실제 원소가 아닌 끝(past the end)을 표시하는 원소라는 것이다.

시작주소 반환이야 할 수 있다고 쳐도 end()는 어떻게 끝 지점을 반환하는 것인지 이해가 되질 않아서 찾아봤는데 뭐 그냥 two pointer를 사용해서 O(1)의 시간복잡도로 end point를 반환하는 것 같다.


---

## 컨테이너 멤버 함수 empty()의 동작

iterator를 공부하니까 empty의 내부 구현이 어떻게 되어있는지 알게 되었다..

이게 정확히 맞는지는 모르겠지만 이렇게 begin() == end() 이면 container가 비어있는 상황이다.

```cpp
bool empty(const STL_Container& container){
    return container.begin() == container.end();
}
```

---

## 대충 사용 예시들

```cpp

map<int> m;

블라블라블라

map<int>::iterator iter; // map container의 iterator 선언 ---> 이름은 iter로 잡은 것.

for(iter = m.begin(); iter != m.end(); ++iter)
~~~

위와 같이 iter를 선언하지 않고 사용하고 싶다면

for(auto iter = m.begin(); iter != m.end(); ++iter)

이렇게 사용해도 된다.
```

keyword auto란 무엇이냐? 초깃값의 형식에 맞춰 선언하면 인스턴스(변수)의 형식이 자동으로 결정되는 타입 추론이라고 한다. 

>함수의 매개변수에는 사용 금지이며, cpp 14부터 함수 반환 타입으로 사용이 가능해졌다.


(사실 써본적이 없기 때문에 잘 모르겠다, 함수의 반환 타입으로는 들어오는 변수의 초깃값에 맞춰서 해당 자료형으로 return이 되나보다.)



또한, 여기서 후위연산자가 아닌 전위 연산자로 iterator를 증가시키는 이유는, 객체의 경우 후위연산자는 현재값을 return한 후에 증가를 하는 작동방식으로, 내부에서 복사생성을 하기 때문에 더 느리기 때문이다.

>이게 무슨 소리냐? 잘 모르겠다. 객체의 경우에만 이러는 것인지... 아닌지...