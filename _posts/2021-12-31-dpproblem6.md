---
title: "가장 긴 바이토닉 부분 수열"
excerpt: "가장 긴 부분 수열의 연장선"

categories:
    - DP
tags:
    - [PS, DP]
last_modified_at: 2021-12-31 
---
# 가장 긴 증가하는 부분 수열 문제 풀이
1. **문제의 이해**
2. 소스코드
3. 후기

백준 문제 링크 [https://www.acmicpc.net/problem/11054](https://www.acmicpc.net/problem/11054)


---

# 1. 가장 긴 바이토닉 부분 수열 문제의 이해

바이토닉 수열이란 문제에서 주어진 설명처럼 증가 수열 -> 감소 수열 이렇게 한번만 바뀌는 경우이다.

따라서 증가수열, 감소수열, 증가-> 감소 이렇게 세가지 수열 중에서 최대로 긴 수열을 찾으면 되는 문제라고 파악했다.

>flag 변수를 도입해서 증가수열, 감소수열 상태표시를 하고 증가수열에서는 감소수열로 넘어갈 수 있다.

이렇게 풀면 가장 긴 증가수열 문제와 비슷하게 풀 수 있을 것이라고 생각했다. 

하지만 조금 더 생각해보니까 현재 보고있는 숫자가 증가수열을 형성하는 수인지, 감소수열을 형성하는 수인지 수의 길이만 보고 판단을 하면 모든 경우에 대해서 확인이 불가능한 Greedy한 동작을 하게 될 것이라는 결론을 내렸다.


즉, flag 변수를 도입하지 않고 이차원 DP 배열을 통해 한쪽은 증가수열, 한쪽은 감소수열을 체크해주면서 증가수열에선 감소수열로 넘어올 수 있게하면 모든 경우에 대해서 확인이 가능한 DP state가 되겠구나라는 결론을 내렸다!. 


---


# 2. 소스코드

```c
#include <stdio.h>

int num[1001];
int dp[1001][2];
int n;

void init();
void do_dp();

int main()
{
	init();
	do_dp();
	int max = 0;
	for (int i = 1; i <= n; i++)
	{
		if (dp[i][0] > max)
			max = dp[i][0];
		if (dp[i][1] > max)
			max = dp[i][1];
	}
	printf("%d", max);
	return 0;
}

void do_dp()
{
	for (int i = 2; i <= n; i++)
	{
		for (int j = 1; j < i; j++)
		{
			if (num[i] > num[j] && dp[i][0] < dp[j][0] + 1) // 증가 수열 체크
				dp[i][0] = dp[j][0] + 1;
			if (num[i] < num[j]) // 감소 수열 체크(증가수열에서 감소수열로 넘어올 수 있음)
			{
				if (dp[i][1] < dp[j][0] + 1)
					dp[i][1] = dp[j][0] + 1;
				if (dp[i][1] < dp[j][1] + 1)
					dp[i][1] = dp[j][1] + 1;
			}
		}
	}
	return;
}


void init()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		scanf("%d", &num[i]);
		dp[i][0] = 1;
		dp[i][1] = 1; // 자기 자신으로 일단 길이 1인 수열이 완성되므로 1로 초기화가 되어있어야함.
	}
	return;
}
```


---

# 후기

자기 자신만으로 수열의 길이가 1인 수열을 형성하므로 DP 배열이 1로 초기화가 되어있어야 하는데 이 부분에 대해서 생각을 하지 못해가지고 한번 틀렸었다.

흠... 이런 반례들은 어떻게 생각해볼 수 있을지 문제를 풀 때 고민해봐야겠다.