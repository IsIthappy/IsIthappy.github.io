---
title: "외판원 순회 문제"
excerpt: "하나하나 얻어갈게 많은 문제"

categories:
    - DP
tags:
    - [PS, DP, Bit Masking]
last_modified_at: 2021-08-27 
---
# 외판원 순회 문제 풀이
1. **외판원 순회 문제의 이해**
2. **Top - down DP로 풀 생각을 한 이유**
3. **문제 풀이**
4. 소스코드
5. **아직 이해 못한 부분**
6. **후기**


백준 문제 링크
[https://www.acmicpc.net/problem/2098](https://www.acmicpc.net/problem/2098)

---

## 1. 외판원 순회 문제의 이해
- P vs NP (추후에 정리해서 링크 추가할 예정)

NP-난해 문제에 해당한다.
NP 문제는 다항시간안에 풀기 위해 다양한 풀이법을 동원하는데 아직 이 문제의 경우에는 아직 다항시간 안에 푸는 방법이 발견되지 않았다.


- 왜 완전탐색으로 못 푸는가.

정답의 경로가 싸이클이 형성되기 때문에 출발 지점이 어느 노드가 되든 상관이 없다.
`O((N-1)!)` 의 시간 복잡도가 나오며 다항 시간안에 문제를 해결할 수 없기 때문에 완전탐색 방식으로는
N>13 일때부터 시간 제한이 있는 경우 옳은 풀이법이 되지 못한다.
따라서 풀이 시간을 줄일 방법을 생각해야 한다.


---


## 2. Top - down DP로 풀 생각을 한 이유
완전 탐색의 경우

1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 1

1 -> 3 -> 2 -> 4 -> 5 -> 6 -> 1

이 경우 4 -> 5 -> 6 -> 1 의 루트로 가는 값은 이미 계산한 적이 있는 경우다.
근데 완전 탐색으로 풀게 된다면 값을 다시 계산하는 불필요한 과정이 들어가게 된다.

그래서 **`메모리에 값을 저장시켜 놓은 다음, 계산한 적이 있는 state라면 바로 메모리에 저장된 값을 꺼내쓰면 되겠다.`** 라는 생각을 떠올릴 수 있다.
현재 상태를 결정하기 위해 필요한 subproblem이 이미 결정된 state라면 값을 바로 return 해주어야 불필요한 연산을 줄일 수 있기 때문이다.

>현재 상태에서 필요한 이전 state의 값이 결정된 값인지 아닌지 확인하고 불필요한 연산을 막아주는 풀이는 재귀 형식으로 문제를 푸는 것이 생각하기가 쉽다.


---


## 3. 문제 풀이

- DP 문제를 풀기 위해선 state 정의가 가장 중요하다.
-> state들의 값을 메모리에 올려 저장하고, 모든 state는 한번만 계산되게끔 만들어져야 하기 때문이다.

이 문제에서 state는
거쳐온 마을이 1 , 2 , 3 이고 현재 위치가 4일때 4까지 오기 위한 최소 경로 비용이 들어가게 될 것이다.

1 -> 2 -> 3 -> 4

1 -> 3 -> 2 -> 4 

둘 중에 뭐로 왔든 내가 궁금한건 최소 비용을 보장하는 경로이기 때문이다.

>하지만 state를 표현하기가 정말 난감하다.
visit 배열로 관리를 할 수 있을까 생각해봐도 답이 없다.
현재 위치가 3일때 그 상태가 몇개의 마을을 거쳐온 상태인지까지 알아야 하는데 데이터 관리하기가 현실적으로 힘들어 보인다.

그래서 bit masking으로 state를 표현한다. 거쳐온 마을들의 상태를 비트단위로 표현하면 모든 state들을 효율적으로 관리할 수 있다.

> bit masking을 할때 1<<n 은 1을 n번 비트 이동시키는 것이므로 자릿수는 2^n이 되는걸 조심하자. 0번째 자리 비트부터 시작이다.



- 재귀 형식에 쓸 점화식 구하기.
top - down DP로 구현할때 초점을 맞춰서 생각해야할 부분은 현재 state를 결정하기 위해
필요한 sublem이 무엇이냐 이다.

여기선 1-> 2-> 3-> 4-> 5 -> 1

최종 state인 마지막 1번 마을에서 최소비용을 결정하기 위해

다른 마을들을 모두 방문하고 마지막으로 2 , 3 , 4 ,5 마을 중 어디서 1번 마을로 오는게 제일 적은 비용이 들까?이다.

이걸 점화식으로 나타내면 된다. 


---

## 4. 소스 코드

```c
#include <stdio.h>
#define MIN(a , b) ( ((a) < (b)) ? (a) : (b) )

int impossible = 1000000000;

int n, arr[16][16], dp[16][1<<16];

int tsp(int,int);

int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
            scanf("%d",&arr[i][j]);
    }
    printf("%d",tsp(0,(1<<n)-1));
    // 최종 state는 모든 마을을 방문한 상태
    return 0;
}


int tsp(int cur, int visit)
{
    if(dp[cur][visit]>0)
        return dp[cur][visit];
    if((visit & ~(1<<cur)) == 0) // base condition
    {
        if(arr[0][cur] == 0)
            return impossible;
        else
            return arr[0][cur];
    }
    dp[cur][visit] = impossible;
    for(int i=1;i<n;i++)
    {
        if( i!=cur && ((1<<i)&visit)!=0 && arr[i][cur] != 0)
            dp[cur][visit] = MIN(dp[cur][visit],tsp(i,visit&~(1<<cur))+arr[i][cur]);
    }
    return dp[cur][visit]; // final state
}
```

직관적으로 이해하기 쉽게 최종 state에 필요한 subproblem이 무엇일까에만 초점을 맞춰서 생각한 후 base condition을 정해줬다.

- **base condition**

방문한 마을이 한개인 상태. --> 이전 마을은 무조건 1번 마을인 상태이기 때문에 값을 바로 정해줄 수 있다.


- **점화식의 구성** 

현재 상태를 결정하기 위해 필요한건 현재 내 마을로 오기 전 어느 마을에서 오는게 제일 가까운지를 찾는 것이다.


- **impossible의 값**

어떤 state든 일단 방문한다면 값이 들어가야한다. 불가능하든 가능하든 계산된 적이 있는 state인지 구분해야 하기 때문이다.

이 문제에서는 -1을 넣어버리면 최솟값 비교에서 꼬이기 때문에 대충 큰 값을 정의해서 넣어준 것이다.

- **시간 복잡도**

DP state의 수 * state당 필요한 연산 == (n*2^n) * n => O(N^2 * 2^N) 지수시간이 나온다.

---

## 5. 아직 이해 못한 점

외판원 순회 문제를 검색하면 구글에 돌아다니는 풀이법이다.

```c
    printf("%d",tsp(0,1)); // 최종 state 00001

int tsp(int cur, int visit)
{
    if(dp[cur][visit] >0)
        return dp[cur][visit];
    if(visit == (1<<n)-1) // base condition
    {
        if(arr[cur][0]!=0)
            return arr[cur][0];
        return impossible; 
    }
    dp[cur][visit] = impossible;
    for(int i=0;i<n;i++)
    {
        if(i != cur && visit&(1<<i)==0 || arr[cur][i] == 0)
            continue;
        dp[cur][visit] = min(dp[cur][visit],tsp(i,visit|(1<<i))+arr[cur][i]);
    }
    return dp[cur][visit]; // final state
}
```

최종 state가 1번 마을만 방문한 상태가 되며 base condition은 모든 마을을 다 방문한 상태가 된다.

완전탐색 혹은 바텀업으로 생각을 해보면 모든 마을을 방문한 상태가 끝이기 때문에 이런 이 state 진행 순서가 맞다.

근데 이건 top-down 구현한 것이기 때문에 최종 state에서 거슬러 내려가야 하는거 아닌가??? 이 풀이 때문에 이 문제를 이해하는데 엄청 오래걸렸다.

시간도 내 풀이법보다 조금 덜 걸리긴 한다 더 깔끔하니까 뭐... 근데 이해를 못하겠다. 어떻게 이렇게 state를 출발했는지...

---
## PS
음... 드디어 이해를 했다... 그냥 단순히 바라보는 관점의 차이였다. 

나는 탑다운 DP를 쓰면 큰 상태에서 작은 상태로 내려가는거라 생각했는데 어떻게보면 큰 상태인지, 작은 상태인지 정의하는거 자체가 틀에 얽매이는 사고인 것 같다.

그냥 현재 상태를 결정하기 위해 필요한 것이 무엇인가? 가 핵심인데.. 그냥 중복 호출만 막아주면 되는 것인데...

1 -> 2 -> 3 -> 4 -> 5 -> 1

1 -> 3 -> 2 -> 4 -> 5 -> 1

의 경로가 있을때, 1 -> 3 -> 2 를 거쳐서 4를 방문한 순간 그 뒤는 이미 구한 적이 있는 경로이기 때문에 값을 다시 구할 필요가 없어진다. 근데 나는 0000001 state에서 출발하면 중복호출을 어떻게 막아준다는 것인지 이해를 못했었다. dfs랑 같은 호출 순서인데 어떻게 뒤에 호출될 경로가 뭔지 알고 막아준다는 것인가?

> DP 배열에 저장되는 값을 잘 보자

 {1,2,3} 마을을 거쳐서 4번 마을이 현재 마을 위치일 때 

그곳에 저장되는 값은 4번 마을에서 현재 방문하지 않은 노드들을 최소비용으로 방문하는 값이 저장된다.

 즉, 5번, 1번 마을을 최소비용으로 방문하는 값이 저장된다...

> 중복호출을 어떻게 막아주는건지 이 쉬운걸 이제 이해하다니...

`손으로 한번만 저장되는 경로를 직접 써봤으면... 이해하기가 한결 수월했을 것이다... 제발 손으로 써보자 이해를 못하겠으면`

---

## 후기

진짜 정말 어려웠다. 단순 완전 탐색으로 풀면 아무 생각없이 풀었을텐데 이 문제에서
- P vs NP
- DP란 무엇인가
- 비트마스킹

이 세가지 개념을 다시 다 찾아서 공부했다... 

사실 P, NP 개념은 크게 중요한가 싶지만 그냥 모르는게 찜찜해서 찾아봤다.

DP랑, 비트마스킹은 얄팍하게 알고 쓰면 혼자 힘으로 풀려고 할때 어디선가 분명이 꼬인다.

정확하게 내가 이해를 해야 구글에 돌아다니는 소스코드에 얽매이지 않고 생각해볼 수 있는 것 같다. 거의 3~4일은 이 문제만 생각한 것 같다... 

`왜 DP로 풀었을까?` 이거랑 `top-down 방식 state 정의` 이 부분에서 엄청 고민을 많이했다.