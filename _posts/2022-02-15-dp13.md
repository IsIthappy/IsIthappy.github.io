---
title: "전구 장식"
excerpt: "관리해야 할 state가 많다고 생각해서 DP인줄 몰랐던 문제"

categories:
    - DP
tags:
    - [PS, DP]
last_modified_at: 2022-02-15
---
# 전구 장식 문제 풀이
1. **문제의 이해**
2. 소스코드

백준 문제 링크 [https://www.acmicpc.net/problem/5527](https://www.acmicpc.net/problem/5527)


---


# 1. 전구 장식 문제의 이해

일단 문제를 딱 보자마자 든 생각은, 같은 전구가 반복해서 위치한다면? 그것을 flip할 것인지, 아니면 새출발할 것인지를 정해야한다.

즉, 반복되는 전구가 위치하는 모든 지점에서 flip, 새출발 두가지 경우의 수로 나누어지며 앞에서 flip한 것이 뒤에서 flip한 것보다 효율적이라는 보장이 안되기 때문에 greedy하게 판단하는 것은 불가능하다. 여기까지는 뭐 쉽게 파악이 가능했다.

>그럼 brute force인가?

완전 탐색이긴 하다. 하지만 dfs기반으로 완전 탐색을 한다고 했을 때, 같은 전구가 위치해서 쭈르르르르르륵 다 보기 시작한다면? 또 다시 돌아와서 다음 위치에서 쪼르르르르르르르륵 본다면? 음... 시간초과가 뜰 것이다...

그럼 보고 다시 돌아와서 훑는 과정이 아니라 한번에 훑어서 봐야하는데 일단 stack에 담아서 진행하면 될 것 같지도 않고... 그럼 DP라는 생각이 드는데...

똑같은 전구가 나왔을 때

1. 뒤집지 않고 새출발하는 state
2. 뒤집기 시작하는 state
3. 뒤집은 것이 끝나서 더 이상 뒤집지 못하고 진행하는 state

얘내들을 어떻게 관리할 것인지 도저히 감이 오질 않아서 DP는 아니라고 생각했다.

>그래서 똑같은 전구가 나온다면 (2,3번 state)그것들을 큐에 넣어서 관리를 하자!

라고 생각하고 구현을 할려고 했다. 아무리 흐름이 분기가 되어도 이미 분기된 흐름에서 또 가지를 쳐서 진행하지는 않기 때문에 충분히 이게 시간안에 들어올 것이라고 생각했다.

살짝 찝찝한 부분은 똑같은 전구가 나와서 큐에 들어간 state들을 매애애애번 큐에 들어갔다가 나왔다가 해야하기 때문에, 여기에 걸리는 추가시간이 영 찝찝했다.


>근데 잘 생각해보면,,, 저 state들을... dp[n][3] 이렇게 잡으면 큐 없이도 관리가 가능해진다...

똑같은 전구가 나오면, 

새출발하는 0번 state, 카운트하던 길이를 1번 state에 그대로 넘겨주고, 

또 똑같은 전구가 나오면, 0번 state에서는 다시 1번 state로 넘겨주고 진행중이던 1번 state가 있었다면 그것을 2번 state가 받아주는 것이다.

아니 이렇게 풀면 될 것을.... 관리해야 하는 흐름이 여러개다. -> 이 말은 ``즉, state가 여러개다``, 그냥 다차원 dp로 한번 잡아서 풀어볼까?

이렇게 흐름이 진행됐다면 빨리 풀 수 있는 문제였다... 그냥 내가 바보였다.

---

# 2. 소스코드

```c
#include <stdio.h>

int n;
int arr[100000];
int dp[100000][3];

void init();
void do_dp();
int find_ans();

int main()
{
	init();
	do_dp();
	printf("%d", find_ans());
	return 0;
}

void do_dp()
{
	dp[0][0] = 1; // 시작점은 일단 하나 카운트 해주고
	for (int i = 1; i < n; i++)
	{
		if (arr[i] == arr[i - 1]) // 전구가 같으니까 스위칭 해주거나 초기화 해야함.
		{
			dp[i][0] = 1;
			dp[i][1] = dp[i - 1][0] + 1;
			if (dp[i - 1][1] > 0)
				dp[i][2] = dp[i - 1][1] + 1;
		}
		else // 전구가 다르니까 그냥 이어서 카운트 해주면 된다.
		{
			dp[i][0] = dp[i - 1][0] + 1;
			if (dp[i - 1][1] > 0)
				dp[i][1] = dp[i - 1][1] + 1;
			if (dp[i - 1][2] > 0)
				dp[i][2] = dp[i - 1][2] + 1;
		}
	}
	return;
}

int find_ans()
{
	int max = 0;
	for (int i = 0; i < n; i++)
	{
		if (max < dp[i][0])
			max = dp[i][0];
		if (max < dp[i][1])
			max = dp[i][1];
		if (max < dp[i][2])
			max = dp[i][2];
	}
	return max;
}

void init() // 수를 바로 입력받으면서 (현재 수, 이전 수)만 기억하면 되지만 그냥 메모리 조금 더 잡아서, 편하게 풀자
{
	scanf("%d", &n);
	for (int i = 0; i < n; i++)
		scanf("%d", &arr[i]);
	return;
}
```
